const { prisma } = require("../../config/prisma.config");
const Logger = require("../../utils/logger");
/** @typedef {import('./audit.type').AuditLogEvent} AuditLogEvent */

const logBuffer = [];
let flushTimer = null;
let isFlushing = false; // Prevent multiple concurrent flushes

const BUFFER_SIZE = 10; // Flush when buffer reaches this size
const FLUSH_INTERVAL_MS = 5000; // Flush every 5 seconds

const auditService = {};

/**
 *
 * @param {*} param0
 * @param {number} param0.tenantID
 * @param {number} param0.skip
 * @param {number} param0.take
 * @returns
 */
auditService.getAuditLogsByTenantID = async ({ tenantID, skip, take }) => {
  try {
    Logger.log("info", {
      message: "auditService:getAuditLogsByTenantID:params",
      params: { tenantID, skip, take },
    });

    const auditLogs = await prisma.tblAuditLogs.findMany({
      where: { tenantID },
      skip,
      take,
      orderBy: { createdAt: "desc" },
    });
    const auditLogsCount = await prisma.tblAuditLogs.count({
      where: { tenantID },
    });

    Logger.log("info", {
      message: "auditService:getAuditLogsByTenantID:auditLogs",
      auditLogs,
      auditLogsCount,
    });

    return { auditLogs, auditLogsCount };
  } catch (error) {
    Logger.log("error", {
      message: "auditService:getAuditLogsByTenantID:catch-1",
      params: { error },
    });
    throw error;
  }
};

/**
 * @param {AuditLogEvent} event - The audit log event to buffer.
 */
auditService.log = (event) => {
  if (
    !event ||
    typeof event.type !== "string" ||
    typeof event.success !== "boolean"
  ) {
    Logger.log("error", {
      message: "auditService:log:invalidEvent",
      params: { event },
    });
    return;
  }
  logBuffer.push(event);
  Logger.log("info", {
    message: "auditService:log:addedToBuffer",
    params: { logBufferLength: logBuffer.length },
  });
  if (logBuffer.length >= BUFFER_SIZE) {
    setImmediate(auditService.flushBuffer);
  }
};

/**
 * @returns {Promise<void>}
 */
auditService.flushBuffer = async () => {
  if (isFlushing || logBuffer.length === 0) {
    return; // Already flushing or nothing to flush
  }

  isFlushing = true;
  // Take all logs from the buffer atomically
  const logsToWrite = logBuffer.splice(0, logBuffer.length);

  try {
    // Map buffered events structure to Prisma tblAuditLogs model structure
    const dataToCreate = logsToWrite.map((log) => ({
      // auditLogID is auto-generated by the database
      userID: log.userID || null, // Use null for optional fields if undefined
      tenantID: log.tenantID || null, // Use null for optional fields if undefined
      type: log.type,
      subType: log.subType || null, // Use null for optional fields if undefined
      success: log.success,
      // createdAt defaults to now() in Prisma, unless provided in log.createdAt
      // If you want to use the event's timestamp, uncomment the line below and adjust Prisma schema:
      // createdAt: log.createdAt ? new Date(log.createdAt) : undefined,
      metadata: log.metadata || null, // Use null for optional fields if undefined
      error: log.error || null, // Use null for optional fields if undefined
    }));

    if (dataToCreate.length > 0) {
      await prisma.tblAuditLogs.createMany({
        data: dataToCreate,
        skipDuplicates: true, // Optional: depending on your needs
      });
    }
  } catch (error) {
    Logger.log("error", {
      message: "auditService:flushBuffer:catch-1",
      params: { error },
    });
  } finally {
    isFlushing = false;
  }
};

/**
 * Starts the background timer for flushing the buffer periodically.
 */
auditService.startFlusher = () => {
  if (flushTimer === null) {
    flushTimer = setInterval(() => {
      // Use setImmediate to ensure the timer callback doesn't block the main loop
      // if the flush operation takes some time.
      setImmediate(auditService.flushBuffer);
    }, FLUSH_INTERVAL_MS);
    Logger.log("info", {
      message: "auditService:startFlusher:started",
      params: { FLUSH_INTERVAL_MS, BUFFER_SIZE },
    });
  }
};

/**
 * @returns {Promise<void>}
 */
auditService.stopFlusher = async () => {
  if (flushTimer !== null) {
    clearInterval(flushTimer);
    flushTimer = null;
    Logger.log("info", {
      message: "auditService:stopFlusher:stopped",
    });
  }
  // Attempt one last flush for any remaining logs in the buffer
  await auditService.flushBuffer();
  Logger.log("info", {
    message: "auditService:stopFlusher:finalFlushComplete",
  });
};

module.exports = {
  auditService,
};
